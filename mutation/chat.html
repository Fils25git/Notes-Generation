<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Teacher Chat</title>
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex flex-col" style="height:100dvh;">

  <!-- Header -->
  <header class="bg-white shadow px-4 py-3 flex items-center justify-between flex-shrink-0">
    <h1 id="chatHeader" class="text-lg font-semibold text-blue-700"></h1>
  </header>

  <!-- Messages + Footer wrapper -->
  <div class="flex flex-col flex-1" style="min-height:0;">

    <!-- Messages Area -->
    <main id="chatMessages" class="flex-1 overflow-y-auto p-4 space-y-3" 
          style="padding-bottom:5.5rem;"></main> <!-- leave more space for footer -->

    <!-- Floating new message indicator -->
<div id="newMessageIndicator" 
     class="fixed bottom-20 right-4 bg-blue-600 text-white px-4 py-2 rounded-full shadow-lg cursor-pointer hidden">
  0 new messages
</div>
    <!-- Input Footer -->
    <footer class="bg-white p-2 border-t flex gap-2 flex-shrink-0"
            style="height:4.5rem; padding-bottom:env(safe-area-inset-bottom);">
      <textarea 
        id="chatInput"
        rows="1"
        class="flex-1 border rounded-2xl px-4 py-2 outline-none focus:ring-2 focus:ring-blue-400 resize-none"
        placeholder="Type a message..."
        style="height:3.5rem;"  <!-- leave button space --></textarea>
      <button 
    id="sendBtn"
    class="bg-blue-600 text-white px-5 rounded-full hover:bg-blue-700 transition flex items-center justify-center"
    style="height:100%;">
    Send
      </button>
    </footer>

  </div>

</body>

    <script>
const chatMessages = document.getElementById("chatMessages");
const chatInput = document.getElementById("chatInput");
const sendBtn = document.getElementById("sendBtn");
const newMsgIndicator = document.getElementById("newMessageIndicator");

let myId = localStorage.getItem("userId");
let receiverId = localStorage.getItem("chatReceiverId");
let receiverName = localStorage.getItem("chatReceiverName");
document.getElementById("chatHeader").textContent = `Chat with ${receiverName}`;

let lastMessageId = 0; // track last displayed message
let newMsgCount = 0;

// Create chat bubble
function createBubble(message, isMine) {
  const div = document.createElement("div");
  div.className = `flex ${isMine ? "justify-end" : "justify-start"}`;

  const bubble = document.createElement("div");
  bubble.className = `
    max-w-xs px-4 py-2 rounded-2xl shadow
    ${isMine ? "bg-blue-600 text-white rounded-br-none" : "bg-white text-gray-800 rounded-bl-none"}
  `;
  bubble.textContent = message;

  div.appendChild(bubble);
  return div;
}

// Check if user is scrolled near bottom
function isScrolledToBottom() {
  return chatMessages.scrollHeight - chatMessages.scrollTop <= chatMessages.clientHeight + 20;
}

// Show floating new message indicator
function showNewMsgIndicator(count) {
  newMsgIndicator.textContent = `${count} new message${count > 1 ? "s" : ""}`;
  newMsgIndicator.classList.remove("hidden");
}

// Hide floating new message indicator
function hideNewMsgIndicator() {
  newMsgCount = 0;
  newMsgIndicator.classList.add("hidden");
}

// Scroll to bottom
function scrollToBottom() {
  chatMessages.scrollTop = chatMessages.scrollHeight;
  hideNewMsgIndicator();
}

// Click floating indicator => scroll to bottom
newMsgIndicator.addEventListener("click", scrollToBottom);

// Load and append only new messages
async function loadMessages() {
  try {
    const token = localStorage.getItem("auth_token");
    const res = await fetch(`/.netlify/functions/get-messages?receiver_id=${receiverId}`, {
      headers: { "Authorization": "Bearer " + token }
    });
    const data = await res.json();

    const atBottom = isScrolledToBottom();

    data.messages.forEach(m => {
      if (m.id <= lastMessageId) return; // skip old messages

      const isMine = String(m.sender_id) === String(myId);
      const bubble = createBubble(m.message, isMine);
      chatMessages.appendChild(bubble);
      lastMessageId = m.id;

      if (atBottom || isMine) {
        bubble.scrollIntoView({ behavior: "smooth", block: "end" });
        hideNewMsgIndicator();
      } else {
        newMsgCount++;
        showNewMsgIndicator(newMsgCount);
      }
    });
  } catch (err) {
    console.error("Error loading messages:", err);
  }
}

// Send message function (with button disable)
async function sendMessage() {
  const message = chatInput.value.trim();
  if (!message) return;

  sendBtn.disabled = true;          // disable button while sending
  sendBtn.classList.add("opacity-50"); // optional visual feedback

  try {
    const token = localStorage.getItem("auth_token");
    await fetch(`/.netlify/functions/send-message`, {
      method: "POST",
      headers: { 
        "Content-Type": "application/json",
        "Authorization": "Bearer " + token 
      },
      body: JSON.stringify({ receiver_id: receiverId, message })
    });

    chatInput.value = "";
    chatInput.style.height = 'auto'; // reset textarea height
    await loadMessages();
    scrollToBottom();
  } catch (err) {
    console.error("Error sending message:", err);
  } finally {
    sendBtn.disabled = false;         // re-enable button
    sendBtn.classList.remove("opacity-50");
  }
}

// Enter = new line, Shift+Enter = send
chatInput.addEventListener("keydown", e => {
  if (e.key === "Enter") {
    if (e.shiftKey) {
      e.preventDefault();   // Shift+Enter sends message
      sendMessage();
    } else {
      // Enter alone = new line (default behavior)
    }
  }
});

// Optional: also send via button click
sendBtn.addEventListener("click", sendMessage);

// Auto-resize textarea
chatInput.addEventListener("input", () => {
  chatInput.style.height = 'auto';
  chatInput.style.height = chatInput.scrollHeight + 'px';
});

// Auto-refresh every 3s
setInterval(loadMessages, 3000);
loadMessages();
  </script>

</body>
  </html>
