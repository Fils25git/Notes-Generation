<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Teacher Chat</title>
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex flex-col" style="height:100dvh;">

  <!-- Header -->
  <header class="bg-white shadow px-4 py-3 flex items-center justify-between flex-shrink-0">
    <h1 id="chatHeader" class="text-lg font-semibold text-blue-700"></h1>
  </header>

  <!-- Messages + Footer wrapper -->
  <div class="flex flex-col flex-1" style="min-height:0;">

    <!-- Messages Area -->
    <main id="chatMessages" class="flex-1 overflow-y-auto p-4 space-y-3" 
          style="padding-bottom:5.5rem;"></main> <!-- leave more space for footer -->

    <!-- Floating new message indicator -->
<div id="newMessageIndicator" 
     class="fixed bottom-20 right-4 bg-blue-600 text-white px-4 py-2 rounded-full shadow-lg cursor-pointer hidden">
  0 new messages
</div>
    <!-- Input Footer -->
    <footer class="bg-white p-2 border-t flex gap-2 flex-shrink-0"
            style="height:4.5rem; padding-bottom:env(safe-area-inset-bottom);">
      <textarea 
        id="chatInput"
        rows="1"
        class="flex-1 border rounded-2xl px-4 py-2 outline-none focus:ring-2 focus:ring-blue-400 resize-none"
        placeholder="Type a message..."
        style="height:3.5rem;"  <!-- leave button space --></textarea>
      <button 
    id="sendBtn"
    class="bg-blue-600 text-white px-5 rounded-full hover:bg-blue-700 transition flex items-center justify-center"
    style="height:100%;">
    Send
      </button>
    </footer>

  </div>

</body>

<script>
let myId = localStorage.getItem("userId");
let receiverId = localStorage.getItem("chatReceiverId");
let receiverName = localStorage.getItem("chatReceiverName");

document.getElementById("chatHeader").textContent = `Chat with ${receiverName}`;

// Create bubble
function createBubble(message, isMine) {
  const div = document.createElement("div");
  div.className = `flex ${isMine ? "justify-end" : "justify-start"}`;

  const bubble = document.createElement("div");
  bubble.className = `
    max-w-xs px-4 py-2 rounded-2xl shadow
    ${isMine ? "bg-blue-600 text-white rounded-br-none" : "bg-white text-gray-800 rounded-bl-none"}
  `;
  bubble.textContent = message;

  div.appendChild(bubble);
  return div;
}

// Load messages
let lastMessageId = null; // keep track of last message displayed

async function loadMessages() {
  const token = localStorage.getItem("auth_token");
  const res = await fetch(`/.netlify/functions/get-messages?receiver_id=${receiverId}`, {
    headers: { "Authorization": "Bearer " + token }
  });
  const data = await res.json();
  const container = document.getElementById("chatMessages");

  // Find new messages
  let newMessages = data.messages;
  if (lastMessageId) {
    const index = newMessages.findIndex(m => m.id === lastMessageId);
    if (index >= 0) {
      newMessages = newMessages.slice(index + 1); // only messages after last seen
    }
  }

  // Append only new messages
  newMessages.forEach(m => {
    const isMine = String(m.sender_id) === String(myId);
    container.appendChild(createBubble(m.message, isMine));
    lastMessageId = m.id; // update last seen message
  });

  // Scroll if user is at bottom
  const atBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 50;
  if (atBottom && newMessages.length) {
    container.scrollTop = container.scrollHeight;
  }
}
  const newMsgIndicator = document.getElementById("newMessageIndicator");
let newMsgCount = 0;

function isScrolledToBottom() {
  return chatMessages.scrollHeight - chatMessages.scrollTop <= chatMessages.clientHeight + 20;
}

function showNewMsgIndicator(count) {
  newMsgIndicator.textContent = `${count} new message${count > 1 ? "s" : ""}`;
  newMsgIndicator.classList.remove("hidden");
}

function hideNewMsgIndicator() {
  newMsgCount = 0;
  newMsgIndicator.classList.add("hidden");
}

// Clicking indicator scrolls to bottom
newMsgIndicator.addEventListener("click", () => {
  chatMessages.scrollTop = chatMessages.scrollHeight;
  hideNewMsgIndicator();
});

// Modified loadMessages
async function loadMessages() {
  const token = localStorage.getItem("auth_token");
  const res = await fetch(`/.netlify/functions/get-messages?receiver_id=${receiverId}`, {
    headers: { "Authorization": "Bearer " + token }
  });
  const data = await res.json();

  data.messages.forEach(m => {
    if (m.id <= lastMessageId) return; // skip already shown
    const isMine = String(m.sender_id) === String(myId);
    const bubble = createBubble(m.message, isMine);
    chatMessages.appendChild(bubble);
    lastMessageId = m.id;

    if (isScrolledToBottom()) {
      bubble.scrollIntoView({ behavior: "smooth", block: "end" });
      hideNewMsgIndicator();
    } else {
      newMsgCount++;
      showNewMsgIndicator(newMsgCount);
    }
  });
}
  
// Send message
document.getElementById("sendBtn").addEventListener("click", async () => {
  const input = document.getElementById("chatInput");
  const message = input.value.trim();
  if (!message) return;

  const token = localStorage.getItem("auth_token");

  await fetch(`/.netlify/functions/send-message`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + token
    },
    body: JSON.stringify({
      receiver_id: receiverId,
      message
    })
  });

  input.value = "";
  loadMessages();
});

// Send with Enter key
const chatInput = document.getElementById("chatInput");
const sendBtn = document.getElementById("sendBtn");

// Mobile-proof solution
chatInput.addEventListener("keydown", e => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault(); // Prevent default newline
    sendBtn.click();    // Send message
  }
});

// Fallback: listen to "input" in case some mobile keyboards don't fire keydown
chatInput.addEventListener("input", () => {
  // Optional: resize textarea dynamically
  chatInput.style.height = 'auto';
  chatInput.style.height = chatInput.scrollHeight + 'px';
});

// Auto refresh
setInterval(loadMessages, 3000);
loadMessages();
</script>

</body>
  </html>
